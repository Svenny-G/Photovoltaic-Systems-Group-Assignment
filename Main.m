import MatlabFunctions.*
import CustomFunctions.*

%% PROBLEM 1
%  monthly electricity demand on the left y-axis and the monthly horizontal radiation on the right y-axis.
%  12 months on the x-axis.

% load location data
load('Locations/Aberdeen.mat');
T_Aberdeen = table(N, FF, G_Bn, G_Dh, G_Gh, Az, hs, Ta, Ts);

% disp(T_Aberdeen);
% Variables from Aberdeen.mat
% N:    Cloud cover                         (0-8)
% FF:   Wind speed                          (m/s)
% G_Bn: Beam Normal Irradiance              (W/m^2)
% G_Dh: Diffuse Horizontal Irradiance       (W/m^2)
% G_Gh: Global Horizontal Irradiance        (W/m^2)
% Az:   solar azimut angle (-180 to 180)    (degrees)                  
% hs:   solar altitude angle/height of sun  (degrees)
% Ta:   ambient temperature                 (° C)
% Ts:   surface temperature                 (° C)
Aberdeen_Latitude = 57.150278;  % from wikimedia – geohack
demand_kWh = GetLoadProfileLatitude(Aberdeen_Latitude) * 1e-3;    % assuming (W), converting to kWh (h=1)

% Generate datetime vector
time = datetime(2024,1,1,0,0,0) + hours(0:8759);
months = month(time)';  % month index 1–12 for each hour

% Monthly demand (kWh)
monthly_demand = accumarray(months, demand_kWh, [12, 1]); % needs column vectors

% Irradiance (convert G_Gh to kWh/m^2)
monthly_GGh = accumarray(months, G_Gh * 1e-3, [12, 1]);

%% PLOTTING
%  monthly electricity demand on the left y-axis and the monthly horizontal radiation on the right y-axis.
%  12 months on the x-axis.
figure;
months = 1:12;

yyaxis left
bar(months, monthly_demand, 0.4);
ylabel('Electricity Demand (kWh)');

yyaxis right
plot(months, monthly_GGh, '-o', 'LineWidth', 2);
ylabel('Global Horizontal Irradiation (kWh/m²)');

xlabel('Month');
title('Monthly Electricity Demand and Irradiation – Aberdeen');
xticks(1:12);
xticklabels({'Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'});
legend('Demand', 'GHI', 'Location', 'northwest');
grid on;


%% PROBLEM 2
% Calculate the annual irradiation on each of the allowed mounting places.
% Take into account direct, diffuse, and reflected components of the POA irradiance.
% Choose mounting orientation based on the higher total annual irradiation.

chosen_orientation = strings(1, 8);  % Store best orientation per segment

% loop over all 8 roof segments
for segment = 1:8
    % Compute total irradiation for each orientation
    [G_portrait_total, G_portrait_per_mod, G_module_raw] = calculateTotalIrradiation(segment, 'portrait', ...
        G_Bn, G_Dh, G_Gh, Az, hs);
    [G_landscape_total, G_landscape_per_mod, G_module_raw] = calculateTotalIrradiation(segment, 'landscape', ...
        G_Bn, G_Dh, G_Gh, Az, hs);
    
    % Sum total annual irradiation [Wh/m²]
    total_portrait = sum(G_portrait_total);
    total_landscape = sum(G_landscape_total);

    %test
    %fprintf('Segment %d:\n', segment);
    %fprintf('  Portrait:  %.2f kWh/m²\n', total_portrait * 1e-3);
    %fprintf('  Landscape: %.2f kWh/m²\n', total_landscape * 1e-3);

    % Choose orientation
    if total_portrait >= total_landscape
        chosen_orientation(segment) = "portrait";
        G_best = G_portrait_per_mod;
    else
        chosen_orientation(segment) = "landscape";
        G_best = G_landscape_per_mod;
    end

    % Compute annual irradiation per module [kWh/m²]
    annual_kWh_per_m2 = G_best * 1e-3;

    % Plot only the chosen orientation
    modelfile = sprintf('%s_modules.mat', chosen_orientation(segment));
    m_ix = 1:length(annual_kWh_per_m2);

    color_limits = [300 900];  % exceeds min/max of module irradiations
    
    %test
    %fprintf('  Max module: %.2f kWh/m²\n', max(annual_kWh_per_m2));
    %fprintf('  Min module: %.2f kWh/m²\n', min(annual_kWh_per_m2));

    figure;
    plotModulesOnRoof(modelfile, segment, m_ix, 'irradiation', ...
        annual_kWh_per_m2, color_limits);
    title(sprintf('Segment %d - %s (chosen)', segment, chosen_orientation(segment)));
end

%% PROBLEM 3
%calculate the expected yearly energy output for all four PV modules installed in module position 1 of your roof sector.
[G_landscape_total, G_landscape_per_mod, G_module_raw] = calculateTotalIrradiation(4, 'landscape', ...
        G_Bn, G_Dh, G_Gh, Az, hs);
E = G_landscape_per_mod(1)*1.7e-3*[0.172,0.184,0.196,0.19]; %Calculate energy per annum for each of the four models in kwh/y
'module yield per cost estimate'
E./[0.41*280,0.46*310,0.62*330,0.56*310];

%% PROBLEM 4
% Knowing the irradiance incident on each PV module, weather parameters and the module of
% your choice, calculate the module temperature for every hour of the year for each of the allowed
% mounting places. Make one bar plot with the average module temperature during the daytime (when
% the modules are working) and the months on the horizontal axis. Discuss how these temperatures will
% affect the power generated by the solar panels compared to the case when the modules operate at a
% constant temperature of 25°C.
[G_landscape_total, G_landscape_per_mod, G_module_raw] = calculateTotalIrradiation(4, 'landscape', ...
        G_Bn, G_Dh, G_Gh, Az, hs);

    % Load sky view factors
    filename = sprintf('%s_skylines_%s.mat', 'landscape', 'east');
    data = load(filename, 'svf');
    svf_segment = data.svf{4};  % cell array, one entry per module

    n_modules = length(svf_segment);
G_module_raw;
%using Faiman model since it is the best performing simple model for non-arid climates
Module_temps = repmat(Ta,1,n_modules)+G_module_raw./(25*ones(length(FF),n_modules)+6.84*repmat(FF,1,n_modules)); %U0 and U1 were assumed to be 4.3 and 1.55 respectively based on values found here: https://pvpmc.sandia.gov/modeling-guide/2-dc-module-iv/module-temperature/faiman-module-temperature-model/
%These parameters also replicate the NOCT cell temperature within 0.4 degrees
BarPlotMonthavgModuleWorkingTemp(Module_temps,G_module_raw);

%% PROBLEM 5
% Report the average operating module efficiency (including a rough approximation of system
% losses) and the installed PV power (in kilowatts peak) required to generate X% of the electricity
% consumed annually. Justify your approximation of the system losses. This step will give you a general
% idea of the required number of modules for your case.

%plan: first calculate average operating module efficiency for each hour of the year using TC Pmax and efficiency from the datasheet, then calculate expected yield per panel, assume external DC/AC efficiency 
%assume FF = 74% (rough average between STC=75.0% and NOCT=73.3%), assume ideal diode

%Datasheet & constants
Am = 1.7;
STC_Pmod = 280;
STC_Voc = 39.56;
STC_Vmp = 31.90;
STC_Isc = 9.46;
STC_Imp = 8.80;
STC_efficiency_mod = 0.1721;
STC_T =25;
TC_Isc = 0.069/100;
TC_Voc = -0.312/100;
TC_P = -0.432/100;             
kb_T = 298.15*1.381e-23;
q = 1.602e-19;

annual_demand = sum(monthly_demand);

%COMPUTED MODULE OPERATING EFFICIENCY-------------------------------------- 
T25 = 25*ones(length(FF),n_modules);

T_mod = Module_temps;

G_mod_mask = G_module_raw;
G_mod_mask(G_mod_mask<=0)=NaN;

Mod_Voc = STC_Voc*ones(length(FF),n_modules)+kb_T/q*T_mod.*log(G_mod_mask/1000)+STC_Voc*TC_Voc*(T_mod-T25);
Mod_Isc = STC_Isc*G_mod_mask/1000 + STC_Isc*TC_Isc*(T_mod-T25);
Mod_Pmpp= 0.74*Mod_Voc.*Mod_Isc;
Mod_eff = Mod_Pmpp./G_mod_mask/Am;

valid_hours = ~isnan(Mod_eff) & G_module_raw > 0 & Mod_eff > 0; 
avg_operating_efficiency = mean(Mod_eff(valid_hours));
avg_annual_irradiation = mean(sum(G_module_raw))*1e-3;
avg_annual_energy_dc = mean(avg_annual_irradiation * avg_operating_efficiency * Am);


%Approximated system losses
losses_approx = 0.15;        

avg_effective_efficiency = avg_operating_efficiency*(1-losses_approx);
annual_yield = avg_annual_irradiation*avg_effective_efficiency;


%Grid independence levels -> X% = 45%
X_45 = 45;

Req_generation_X = annual_demand * (X_45/100);
Req_P = Req_generation_X / annual_yield;
Num_Mod = ceil(Req_P*1000/STC_Pmod);
Act_P = Num_Mod * STC_Pmod / 1000;

Q5_resultsA_table = table(X_45', Req_generation_X, Req_P, Num_Mod, Act_P, ...
    'VariableNames', {'Grid independence (%)', 'Req. generation (kWh/year)', ...
                      'Req. power (kWp)', 'Number of modules (#)', 'Actual installed power (kWp)'});

disp('=== RESULTS GRID INDEPENDENCE LEVELS WITH OPERATING EFFICIENCY COMPUTED ===');
disp(Q5_resultsA_table);

%% P5 OPTIONAL -> uncomment (Comparison of operating efficiency computed vs datasheet)

% X_val = [10, 20, 25, 30, 45, 60, 65, 80, 100];
% losses_approx = 0.15;
% P5_Detailed_comparison_Xval_operatingeff_computed_vs_datasheet(monthly_demand,FF,n_modules,Module_temps,G_module_raw, losses_approx, X_val);

%% PROBLEM 6
% Optimize the distribution and interconnection of PV modules on the rooftop. Explain clearly in
% the report (with a simple schematic) how many arrays (groups) of modules compose your PV system
% and how are the modules in each array connected with each other and to the inverter. Try to minimize
% the losses due to current mismatch between series-connected modules. Use the symbol below to
% represent a PV module. Provide moreover a plot of the annual irradiation of only the modules that
% compose your PV system, in the chosen mounting orientation. The limits of the color bar range will be
% provided and depend on the city.

[G_landscape_total, G_landscape_per_mod, G_module_raw] = calculateTotalIrradiation(4, 'landscape', ...
    G_Bn, G_Dh, G_Gh, Az, hs);

annual_irradiation_per_mod = G_landscape_per_mod * 1e-3;
total_available_modules = length(annual_irradiation_per_mod);

[sorted_irradiation, sort_idx] = sort(annual_irradiation_per_mod, 'descend');

if Num_Mod <= total_available_modules
    selected_module_idx = sort_idx(1:Num_Mod);
    selected_irradiation = sorted_irradiation(1:Num_Mod);
else
    fprintf('Warning: Insufficient modules available! Using all %d modules.\n', total_available_modules);
    selected_module_idx = sort_idx;
    selected_irradiation = sorted_irradiation;
    Num_Mod = total_available_modules;
end

Max_mod_strng = 20;  %From datasheet, 60 modules with 3 bypass diodes
N_strngs = ceil(Num_Mod / Max_mod_strng);
Mod_per_strng = floor(Num_Mod / N_strngs);
Mod_remaining = mod(Num_Mod, N_strngs);

%TABLE STRING CONFIGURATION
Q6_strng_config_table = table(Max_mod_strng, N_strngs, Mod_per_strng, Mod_remaining, ...
    'VariableNames', {'Target string size', 'Number of strings', 'Modules per string', ...
                        'Extra modules to distribute'});
disp('--- STRING CONFIGURATION ---');
disp(Q6_strng_config_table);


string_assignments = [];
string_irradiation = cell(N_strngs, 1);
string_modules = cell(N_strngs, 1);

current_string = 1;
direction = 1; 

for i = 1:Num_Mod
    string_assignments(end+1) = current_string;
    current_string = current_string + direction;
    
    if current_string > N_strngs
        current_string = N_strngs;
        direction = -1;
    elseif current_string < 1
        current_string = 1;
        direction = 1;
    end
end

for s = 1:N_strngs
    string_mask = (string_assignments == s);
    string_modules{s} = selected_module_idx(string_mask);
    string_irradiation{s} = selected_irradiation(string_mask);
    String_ID(s) = s;
    Modules_per_String(s) = length(string_modules{s});
    Mean_Irradiation(s) = mean(string_irradiation{s});
    Std_Irradiation(s) = std(string_irradiation{s});
end

%TABLE STRING CONFIGURATION OVERVIEW
Q6_strng_config2_table = table(String_ID', Modules_per_String', Mean_Irradiation', Std_Irradiation', ...
    'VariableNames', {'String_ID', 'Modules', 'Mean_Irradiation_kWh_m2', 'Std_Irradiation_kWh_m2'});
disp('--- STRING CONFIGURATION OVERVIEW ---');
disp(Q6_strng_config2_table);


total_ideal_power = sum(selected_irradiation) * STC_efficiency_mod * Am * STC_Pmod / (STC_efficiency_mod * Am * 1000); 
total_string_power = 0;

for s = 1:N_strngs
    min_irradiation_in_string = min(string_irradiation{s});
    modules_in_string = length(string_modules{s});
    string_power = min_irradiation_in_string * modules_in_string * STC_efficiency_mod * Am * STC_Pmod / (STC_efficiency_mod * Am * 1000);
    total_string_power = total_string_power + string_power;
end

mismatch_loss_pct = (total_ideal_power - total_string_power) / total_ideal_power * 100;

%TABLE MISMATCH VALUES
Q6_mismatch_val_table = table(total_ideal_power, total_string_power, mismatch_loss_pct, ...
    'VariableNames', {'Ideal annual energy (kWh)', 'String-limited energy (kWh)', 'Mismatch loss (%)'});
disp('--- MISMATCH VALUES ---');
disp(Q6_mismatch_val_table);


%LAYOUT SPECS VALUES
fprintf('\n--- LAYOUT SPECS VALUES ---\n');
fprintf('- %d strings connected in parallel\n', N_strngs);
fprintf('- Each string contains %d-%d modules in series\n', ...
    min(cellfun(@length, string_modules)), max(cellfun(@length, string_modules)));
fprintf('- All strings connected to a single inverter with %d MPPT input(s)\n', N_strngs);
fprintf(' \n');


String_ID2 = (1:N_strngs)';
Modules2 = cell(N_strngs, 1);
Mean_Irradiation2 = zeros(N_strngs, 1);
Std_Irradiation2 = zeros(N_strngs, 1);

for s = 1:N_strngs
    modules_str = sprintf('%d,', string_modules{s});
    Modules2{s} = modules_str(1:end-1); 
    Mean_Irradiation2(s) = mean(string_irradiation{s});
    Std_Irradiation2(s) = std(string_irradiation{s});
end

%TABLE STRING BREAKDOWN 
Q6_strng_breakdown_table = table(String_ID2, Modules2, Mean_Irradiation2, Std_Irradiation2, ...
          'VariableNames', {'String_ID', 'Modules', 'Mean_Irradiation_kWh_m2', 'Std_Irradiation_kWh_m2'});
disp('--- STRING BREAKDOWN ---');
disp(Q6_strng_breakdown_table);


selected_mask = false(total_available_modules, 1);
selected_mask(selected_module_idx) = true;

color_limits = [300, 900];

figure;
modelfile = 'landscape_modules.mat';
plotModulesOnRoof(modelfile, 4, selected_module_idx, 'irradiation', ...
    selected_irradiation, color_limits);
title(sprintf('Segment 4: %d modules (%.1f kWp)', ...
    Num_Mod, Num_Mod * STC_Pmod / 1000));
colorbar;
saveas(gcf, fullfile('Figures', 'Problem6.fig'));


%TABLE SUMMARY
Q6_summary_table = table(Num_Mod, Num_Mod * STC_Pmod / 1000, N_strngs, ...
    round(mean(cellfun(@length, string_modules))), total_string_power, ...
    total_string_power / annual_demand * 100, mismatch_loss_pct, ...
          'VariableNames', {'Total modules', 'System power (kWp)', 'Number of strings', ...
    'Modules per string', 'Annual generation (kWh)', 'Grid independence (%)', 'Mismatch loss (%)'});
disp('--- SUMMARY ---');
disp(Q6_summary_table);

%% DISCLAIMER, MOSTLY COPY PASTED FROM AI
fprintf('\n=== ARRAY VISUALIZATION OF MODULES ===\n');
for s = 1:N_strngs
    figure('Name', sprintf('String %d Details', s), 'NumberTitle', 'off');
    
    current_string_modules = string_modules{s};
    current_string_irradiation = string_irradiation{s};
    
    plotModulesOnRoof(modelfile, 4, current_string_modules, 'irradiation', ...
        current_string_irradiation, color_limits);
    
    title(sprintf('String %d: %d Modules (%.1f±%.1f kWh/m²)', ...
        s, length(current_string_modules), ...
        mean(current_string_irradiation), std(current_string_irradiation)));
    
    colorbar;
    text(0.98, 0.98, sprintf('Modules: [%s]', ...
        sprintf('%d, ', current_string_modules)), ...
        'Units', 'normalized', ...
        'HorizontalAlignment', 'right', ...
        'VerticalAlignment', 'bottom', ...
        'BackgroundColor', 'white', ...
        'EdgeColor', 'black', ...
        'FontSize', 6, ...
        'Interpreter', 'none');
    
    fprintf('Created figure for String %d with %d modules\n', s, length(current_string_modules));
end
